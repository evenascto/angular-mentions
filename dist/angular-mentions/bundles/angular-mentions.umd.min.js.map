{"version":3,"sources":["ng://angular-mentions/lib/mention-utils.ts","ng://angular-mentions/lib/caret-coords.ts","ng://angular-mentions/lib/mention-list.component.ts","ng://angular-mentions/lib/mention.directive.ts","ng://angular-mentions/lib/mention.module.ts"],"names":["getValue","el","isInputOrTextAreaElement","value","textContent","insertValue","start","end","insertHTML","text","iframe","noRecursion","nodeName","isTextElement","val","setValue","substring","length","setCaretPosition","selObj","getWindowSelection","rangeCount","HTMLElement","e","getDocument","createElement","innerHTML","makeAngularElements","i","setAttribute","children","anchorNode","beforeString","nodeValue","substr","afterString","positionChar","lastIndexOf","beforeEl","innerText","afterEl","parentNode","insertBefore","nextSibling","range","createRange","selectNode","setStart","setEnd","collapse","removeAllRanges","addRange","insertElement","position","getRangeAt","startOffset","pos","selectionStart","focus","setSelectionRange","sel","getCaretPosition","slice","selRange","preCaretRange","cloneRange","selectNodeContents","endContainer","endOffset","toString","contentWindow","document","getSelection","window","getContentEditableCaretCoords","ctx","markerId","Date","getTime","Math","random","doc","prevRange","markerEl","id","appendChild","createTextNode","insertNode","coordinates","left","top","offsetHeight","element","obj","parent","offsetLeft","clientLeft","offsetTop","clientTop","offsetParent","body","scrollTop","scrollLeft","localToRelativeCoordinates","removeChild","properties","isBrowser","isFirefox","i0.ɵɵtext","i0.ɵɵtextInterpolate1","i0.ɵɵelementStart","i0.ɵɵlistener","ctx_r8","itemClick","emit","$event","preventDefault","i0.ɵɵtemplate","i0.ɵɵelementEnd","i0.ɵɵclassProp","ctx_r3","styleOff","activeIndex","i_r6","i0.ɵɵadvance","i0.ɵɵproperty","core","ɵɵpureFunction1","_c2","item_r5","MentionListComponent","this","labelKey","EventEmitter","items","hidden","dropUp","coords","offset","prototype","ngAfterContentChecked","itemTemplate","defaultItemTemplate","nativeParentElement","options","Error","debug","querySelector","div","style","computed","getComputedStyle","currentStyle","isInput","whiteSpace","wordWrap","visibility","forEach","prop","boxSizing","height","parseInt","outerHeight","paddingTop","paddingBottom","borderTopWidth","borderBottomWidth","targetHeight","lineHeight","scrollHeight","overflowY","overflow","replace","span","backgroundColor","getCaretCoordinates","getBlockCursorDimensions","context","documentElement","pageXOffset","pageYOffset","caretRelativeToView","parentRelativeToContainer","getBoundingClientRect","positionElement","Object","defineProperty","activateNextItem","listEl","list","nativeElement","activeEl","getElementsByClassName","item","nextLiEl","nextLiRect","bottom","clientHeight","max","min","activatePreviousItem","prevLiEl","previousSibling","reset","checkBounds","bounds","width","innerWidth","className","parentStyles","parseFloat","fontSize","ɵɵdirectiveInject","ElementRef","selectors","viewQuery","rf","MentionDirective","_element","_componentResolver","_viewContainerRef","_this","mentionConfig","DEFAULT_CONFIG","triggerChar","maxItems","allowSpace","returnTrigger","mentionSelect","activeConfig","searchTerm","itemSelected","opened","closed","triggerChars","mentionItems","ngOnChanges","changes","updateConfig","config","addConfig","mentions","defaults","assign","map","label","object","filter","disableSort","sort","a","b","localeCompare","updateSearchList","setIframe","stopEvent","event","wasClick","stopPropagation","stopImmediatePropagation","blurHandler","stopSearch","inputHandler","lastKeyCode","data","keyCode","charCodeAt","keyHandler","inputEvent","isComposing","charPressed","key","charCode","which","shiftKey","String","fromCharCode","startPos","startNode","searching","searchString","showSearchList","searchList","metaKey","altKey","ctrlKey","activeItem","evt","createEvent","initEvent","dispatchEvent","mention","startSearch","matches","objects","disableSearch","searchStringLowerCase_1","toLowerCase","startsWith","componentFactory","resolveComponentFactory","componentRef","createComponent","instance","mentionListTemplate","subscribe","fakeKeydown","disableStyle","requestAnimationFrame","ComponentFactoryResolver","ViewContainerRef","hostAttrs","hostBindings","MentionModule","imports","CommonModule","declarations","exports"],"mappings":"6VAagBA,EAASC,GACvB,OAAOC,EAAyBD,GAAMA,EAAGE,MAAQF,EAAGG,qBAGtCC,EACdJ,EACAK,EACAC,EACAC,EACAC,EACAC,EACAC,GAGA,QAHA,IAAAA,IAAAA,GAAA,YAoH4BV,GAC5B,OAAa,MAANA,IAA8B,SAAfA,EAAGW,UAAsC,YAAfX,EAAGW,UAAyC,SAAfX,EAAGW,UAlH5EC,CAAcZ,GAAK,CACrB,IAAIa,EAAMd,EAASC,IAzBvB,SAAkBA,EAAsBE,GAElCD,EAAyBD,GAC3BA,EAAGE,MAAQA,EAGXF,EAAGG,YAAcD,EAoBjBY,CAASd,EAAIa,EAAIE,UAAU,EAAGV,GAASG,EAAOK,EAAIE,UAAUT,EAAKO,EAAIG,SACrEC,EAAiBjB,EAAIK,EAAQG,EAAKQ,OAAQP,QAEvC,IAAKC,EAAa,CACrB,IAAIQ,EAAoBC,EAAmBV,GAC3C,GAAIS,GAAUA,EAAOE,WAAa,EAShC,GAAIb,GA2BV,SACEW,EACAb,EACAC,EACAE,EACAC,GAEA,KAAMD,aAAgBa,aAAc,CAClC,IAAIC,EAAIC,EAAYd,GAAQe,cAAc,QAC1CF,EAAEG,UAAYjB,EACdA,EAAOc,GApBX,SAASI,EAAoB1B,GAC3B,KAAMA,aAAcqB,aAClB,OAGF,IAAK,IAAIM,KADT3B,EAAG4B,aAAa,gBAAiB,IACnB5B,EAAG6B,SACfH,EAAoB1B,EAAG6B,SAASF,IAkBlCD,CAAoBlB,GAEpB,IAAIsB,EAAaZ,EAAOY,WAGpBC,EAAeD,EAAWE,UAAUC,OAAO,EAAG5B,GAC9C6B,EAAcJ,EAAWE,UAAUjB,UAAUT,GAUlD,IAJI6B,EAAeJ,EAAaK,YAAY,MAI1B,EAEjB,IAAID,GADJJ,GAA8B,KACEK,YAAY,KAK7CL,EAAeA,EAAahB,UAAU,EAAIoB,EAAe,GAIxDL,EAAWE,UAAY,GAGvB,IAAIK,EAAWd,EAAYd,GAAQe,cAAc,QACjDa,EAASC,UAAYP,EACrB,IAAIQ,EAAUhB,EAAYd,GAAQe,cAAc,QAChDe,EAAQD,UAAYJ,EAGpBJ,EAAWU,WAAWC,aAAaF,EAAST,EAAWY,aACvDZ,EAAWU,WAAWC,aAAajC,EAAMsB,EAAWY,aACpDZ,EAAWU,WAAWC,aAAaJ,EAAUP,EAAWY,aAGxD,IAAIC,EAAQpB,EAAYd,GAAQmC,cAChCD,EAAME,WAAWN,GACjBI,EAAMG,SAASP,EAAS,GACxBI,EAAMI,OAAOR,EAAS,GAGtBI,EAAMK,UAAS,GACf9B,EAAO+B,kBACP/B,EAAOgC,SAASP,GAzFVQ,CAAcjC,EAAQb,EAAOC,EAAKE,EAAMC,OAErC,CACH,IACI2C,EADWlC,EAAOmC,WAAW,GACTC,YAMxBlD,EALiBc,EAAOY,WAKkBsB,GAAY9C,EAAMD,GAAQ+C,EAAU7C,EAAYC,EAAMC,GAAQ,cAkFhGR,EAAyBD,GACvC,OAAa,MAANA,IAA8B,SAAfA,EAAGW,UAAsC,YAAfX,EAAGW,mBAOrCM,EAAiBjB,EAAsBuD,EAAa9C,GAElE,QAFkE,IAAAA,IAAAA,EAAA,MAE9DR,EAAyBD,IAAOA,EAAGwD,eACrCxD,EAAGyD,QACHzD,EAAG0D,kBAAkBH,EAAKA,OAEvB,CACH,IAAIZ,EAAQpB,EAAYd,GAAQmC,cAChCD,EAAMG,SAAS9C,EAAIuD,GACnBZ,EAAMK,UAAS,GACf,IAAIW,EAAMxC,EAAmBV,GAC7BkD,EAAIV,kBACJU,EAAIT,SAASP,aAIDiB,EAAiB5D,EAAsBS,GAErD,QAFqD,IAAAA,IAAAA,EAAA,MAEjDR,EAAyBD,GAE3B,OADUA,EAAGE,MACF2D,MAAM,EAAG7D,EAAGwD,gBAAgBxC,OAGvC,IAAIE,EAASC,EAAmBV,GAChC,GAAIS,EAAOE,WAAa,EAAG,CACzB,IAAI0C,EAAW5C,EAAOmC,WAAW,GAC7BU,EAAgBD,EAASE,aAI7B,OAHAD,EAAcE,mBAAmBjE,GACjC+D,EAAchB,OAAOe,EAASI,aAAcJ,EAASK,WACtCJ,EAAcK,WAAWpD,QAS9C,SAASO,EAAYd,GACnB,OAAKA,EAGIA,EAAO4D,cAAcC,SAFrBA,SAMX,SAASnD,EAAmBV,GAC1B,OAAKA,EAGIA,EAAO4D,cAAcE,eAFrBC,OAAOD,wBAMFE,EAA8BC,GAC5C,IACIC,EAAW,QAAS,IAAIC,MAAOC,UAAY,IAAMC,KAAKC,SAASX,WAAWnC,OAAO,GACjF+C,EAAMzD,EAAYmD,EAAMA,EAAIjE,OAAS,MACrCkD,EAAMxC,EAAmBuD,EAAMA,EAAIjE,OAAS,MAC5CwE,EAAYtB,EAAIN,WAAW,GAG3BV,EAAQqC,EAAIpC,cAChBD,EAAMG,SAASa,EAAI7B,WAAYmD,EAAU3B,aACzCX,EAAMI,OAAOY,EAAI7B,WAAYmD,EAAU3B,aACvCX,EAAMK,UAAS,GAIf,IAAIkC,EAAWF,EAAIxD,cAAc,QACjC0D,EAASC,GAAKR,EACdO,EAASE,YAAYJ,EAAIK,eAhBJ,WAiBrB1C,EAAM2C,WAAWJ,GACjBvB,EAAIV,kBACJU,EAAIT,SAAS+B,GAEb,IAAIM,EAAc,CAChBC,KAAM,EACNC,IAAKP,EAASQ,cAMhB,OAGF,SACEhB,EACAiB,EACAJ,GAEA,IAAIK,EAAmBD,EACnBlF,EAASiE,EAAMA,EAAIjE,OAAS,KAChC,KAAOmF,IACa,MAAdlB,EAAImB,QAAkBnB,EAAImB,QAAUD,IAGxCL,EAAYC,MAAQI,EAAIE,WAAaF,EAAIG,WACzCR,EAAYE,KAAOG,EAAII,UAAYJ,EAAIK,YACvCL,EAAmBA,EAAIM,eACXzF,IACVmF,EAAMnF,EACNA,EAAS,MAGbmF,EAAmBD,EACnBlF,EAASiE,EAAMA,EAAIjE,OAAS,KAC5B,KAAOmF,IAAQrE,EAAY,MAAM4E,MAAe,MAAPP,IACrB,MAAdlB,EAAImB,QAAkBnB,EAAImB,QAAUD,IAGpCA,EAAIQ,WAAaR,EAAIQ,UAAY,IACnCb,EAAYE,KAAOG,EAAIQ,WAErBR,EAAIS,YAAcT,EAAIS,WAAa,IACrCd,EAAYC,MAAQI,EAAIS,cAE1BT,EAAmBA,EAAIpD,aACX/B,IACVmF,EAAMnF,EACNA,EAAS,MAxCb6F,CAA2B5B,EAAKQ,EAAUK,GAE1CL,EAAS1C,WAAW+D,YAAYrB,GACzBK,EC3NP,IAAIiB,EAAa,CACf,YACA,YACA,QACA,SACA,YACA,YAEA,iBACA,mBACA,oBACA,kBACA,cAEA,aACA,eACA,gBACA,cAGA,YACA,cACA,aACA,cACA,WACA,iBACA,aACA,aAEA,YACA,gBACA,aACA,iBAEA,gBACA,cAEA,UACA,cAIEC,EAA+B,oBAAXjC,OACpBkC,EAAaD,GAA0C,MAA7BjC,OAAwB,iFClClDmC,EAAAA,OAAAA,yCAAAC,EAAAA,mBAAAA,IAAAA,EAAAA,EAAAA,UAAAA,4GAIAC,EAAAA,eAAAA,EAAAA,MAEEA,EAAAA,eAAAA,EAAAA,IAAAA,GACEC,EAAAA,WAAAA,aAAAA,SAAAA,GAAAA,EAAAA,cAAAA,GAAAA,IAAAA,EAAAA,EAAAA,MAAAA,EAAAA,EAAAA,gBAA2C,OAA3CA,EAAAA,YAAAA,EAA2BC,EAAAC,UAAAC,OAAiBC,EAAAC,oBAC5CC,EAAAA,WAAAA,EAAAA,EAAAA,EAAAA,EAAAA,cAAAA,GACFC,EAAAA,eACFA,EAAAA,uEALEC,EAAAA,YAAAA,SAAAA,EAAAA,aAAAA,EAAAA,CAA+B,kBAAAC,EAAAC,UAAAD,EAAAE,aAAAC,GACNC,EAAAA,UAAAA,GAAAL,EAAAA,YAAAA,gBAAAA,EAAAA,UAEVK,EAAAA,UAAAA,GAAAC,EAAAA,WAAAA,mBAAAA,EAAAA,aAAAA,CAAiC,0BAAAC,EAAAC,gBAAA,EAAAC,EAAAC,KAbxD,IAAAC,EAAA,WAgCE,SAAAA,EAAoBtC,GAAAuC,KAAAvC,QAAAA,EAZXuC,KAAAC,SAAmB,QAElBD,KAAAlB,UAAY,IAAIoB,EAAAA,aAG1BF,KAAAG,MAAQ,GACRH,KAAAT,YAAsB,EACtBS,KAAAI,QAAkB,EAClBJ,KAAAK,QAAkB,EAClBL,KAAAV,UAAoB,EACZU,KAAAM,OAAoC,CAAC/C,IAAI,EAAGD,KAAK,GACjD0C,KAAAO,OAAiB,SAGzBR,EAAAS,UAAAC,sBAAA,WACOT,KAAKU,eACRV,KAAKU,aAAeV,KAAKW,sBAK7BZ,EAAAS,UAAAtF,SAAA,SAAS0F,EAAuCrI,GAC9C,QAD8C,IAAAA,IAAAA,EAAA,MAC1CR,EAAyB6I,GAE3BZ,KAAKM,gBDH2B7C,EAASvC,EAAU2F,GACrD,IAAKtC,EACH,MAAM,IAAIuC,MAAM,kFAGlB,IAAIC,EAAQF,GAAWA,EAAQE,QAAS,EACxC,GAAIA,EAAO,CACT,IAAIjJ,EAAKsE,SAAS4E,cAAc,6CAC5BlJ,GAAIA,EAAGwC,WAAW+D,YAAYvG,GAIpC,IAAImJ,EAAM7E,SAAS9C,cAAc,OACjC2H,EAAIhE,GAAK,2CACTb,SAAS6B,KAAKf,YAAY+D,GAE1B,IAAIC,EAAQD,EAAIC,MACZC,EAAW7E,OAAO8E,iBAAmB9E,OAAO8E,iBAAiB3D,GAAWA,EAAQ4D,aAChFC,EAA+B,UAArB7D,EAAQhF,SAGtByI,EAAMK,WAAa,WACdD,IACHJ,EAAMM,SAAW,cAGnBN,EAAMhG,SAAW,WACZ6F,IACHG,EAAMO,WAAa,UAGrBnD,EAAWoD,SAAQ,SAAUC,GAC3B,GAAIL,GAAoB,eAATK,EAEb,GAA2B,eAAvBR,EAASS,UAA4B,CACvC,IAAIC,EAASC,SAASX,EAASU,QAC3BE,EACFD,SAASX,EAASa,YAClBF,SAASX,EAASc,eAClBH,SAASX,EAASe,gBAClBJ,SAASX,EAASgB,mBAChBC,EAAeL,EAAcD,SAASX,EAASkB,YAEjDnB,EAAMmB,WADJR,EAASO,EACQP,EAASE,EAAc,KACjCF,IAAWO,EACDjB,EAASkB,WAET,SAGrBnB,EAAMmB,WAAalB,EAASU,YAG9BX,EAAMS,GAAQR,EAASQ,MAIvBnD,EAEEf,EAAQ6E,aAAeR,SAASX,EAASU,UAC3CX,EAAMqB,UAAY,UAEpBrB,EAAMsB,SAAW,SAGnBvB,EAAIhJ,YAAcwF,EAAQzF,MAAMa,UAAU,EAAGqC,GAGzCoG,IACFL,EAAIhJ,YAAcgJ,EAAIhJ,YAAYwK,QAAQ,MAAO,MAEnD,IAAIC,EAAOtG,SAAS9C,cAAc,QAMlCoJ,EAAKzK,YAAcwF,EAAQzF,MAAMa,UAAUqC,IAAa,IACxD+F,EAAI/D,YAAYwF,GAEhB,IAAIrF,EAAc,CAChBE,IAAKmF,EAAK5E,UAAYgE,SAASX,EAAyB,gBACxD7D,KAAMoF,EAAK9E,WAAakE,SAASX,EAA0B,iBAC3DU,OAAQC,SAASX,EAAqB,aASxC,OANIJ,EACF2B,EAAKxB,MAAMyB,gBAAkB,OAE7BvG,SAAS6B,KAAKI,YAAY4C,GAGrB5D,ECzFSuF,CAAoBhC,EAAqBA,EAAoBtF,eAAgB,MAC3F0E,KAAKM,OAAO/C,IAAMqD,EAAoB9C,UAAYkC,KAAKM,OAAO/C,IAAMqD,EAAoB1C,UACxF8B,KAAKM,OAAOhD,KAAOsD,EAAoBhD,WAAaoC,KAAKM,OAAOhD,KAAOsD,EAAoBzC,WAE3F6B,KAAKO,OAASP,KAAK6C,yBAAyBjC,GAAqBiB,YAE9D,GAAItJ,EAAQ,CACf,IAAIuK,EAA0D,CAAEvK,OAAQA,EAAQoF,OAAQpF,EAAOyF,cAC/FgC,KAAKM,OAAS/D,EAA8BuG,OAEzC,CACH,IAAIhG,EAAMV,SAAS2G,gBACf5E,GAAc7B,OAAO0G,aAAelG,EAAIqB,aAAerB,EAAIe,YAAc,GACzEK,GAAa5B,OAAO2G,aAAenG,EAAIoB,YAAcpB,EAAIiB,WAAa,GAEtEmF,EAAsB3G,EAA8B,CAAEhE,OAAQA,IAC9D4K,EAAwCvC,EAAoBwC,wBAChEpD,KAAKM,OAAO/C,IAAM2F,EAAoB3F,IAAM4F,EAA0B5F,IAAMqD,EAAoB9C,UAAYI,EAC5G8B,KAAKM,OAAOhD,KAAO4F,EAAoB5F,KAAO6F,EAA0B7F,KAAOsD,EAAoBhD,WAAaO,EAGlH6B,KAAKqD,mBAGPC,OAAAC,eAAIxD,EAAAS,UAAA,aAAU,KAAd,WACE,OAAOR,KAAKG,MAAMH,KAAKT,8CAGzBQ,EAAAS,UAAAgD,iBAAA,WAEE,IAAIC,EAAsBzD,KAAK0D,KAAKC,cAChCC,EAAWH,EAAOI,uBAAuB,UAAUC,KAAK,GAC5D,GAAIF,EAAU,CACZ,IAAIG,EAAsCH,EAASpJ,YACnD,GAAIuJ,GAAiC,MAArBA,EAAStL,SAAkB,CACzC,IAAIuL,EAAyBD,EAASX,wBAClCY,EAAWC,OAASR,EAAOL,wBAAwBa,SACrDR,EAAOvF,UAAY6F,EAASjG,UAAYkG,EAAWnC,OAAS4B,EAAOS,eAKzElE,KAAKT,YAAc3C,KAAKuH,IAAIvH,KAAKwH,IAAIpE,KAAKT,YAAc,EAAGS,KAAKG,MAAMrH,OAAS,GAAI,IAGrFiH,EAAAS,UAAA6D,qBAAA,WAEE,IAAIZ,EAAsBzD,KAAK0D,KAAKC,cAChCC,EAAWH,EAAOI,uBAAuB,UAAUC,KAAK,GAC5D,GAAIF,EAAU,CACZ,IAAIU,EAAsCV,EAASW,gBACnD,GAAID,GAAiC,MAArBA,EAAS7L,SACM6L,EAASlB,wBACvB7F,IAAMkG,EAAOL,wBAAwB7F,MAClDkG,EAAOvF,UAAYoG,EAASxG,WAKlCkC,KAAKT,YAAc3C,KAAKuH,IAAIvH,KAAKwH,IAAIpE,KAAKT,YAAc,EAAGS,KAAKG,MAAMrH,OAAS,GAAI,IAIrFiH,EAAAS,UAAAgE,MAAA,WACExE,KAAK0D,KAAKC,cAAczF,UAAY,EACpC8B,KAAKyE,eAKC1E,EAAAS,UAAAiE,YAAR,WACE,IAAInH,EAAO0C,KAAKM,OAAOhD,KAAMC,EAAMyC,KAAKM,OAAO/C,IAAK8C,EAASL,KAAKK,OAC5DqE,EAAqB1E,KAAK0D,KAAKC,cAAcP,wBAE/CsB,EAAOpH,KAAOoH,EAAOC,MAAQrI,OAAOsI,aACtCtH,GAAQoH,EAAOpH,KAAOoH,EAAOC,MAAQrI,OAAOsI,WAAa,IAOvDF,EAAOnH,IAAI,IACb8C,GAAS,GAGXL,KAAKqD,gBAAgB/F,EAAMC,EAAK8C,IAG1BN,EAAAS,UAAA6C,gBAAR,SAAwB/F,EAA8BC,EAA4B8C,QAA1D,IAAA/C,IAAAA,EAAY0C,KAAKM,OAAOhD,WAAM,IAAAC,IAAAA,EAAWyC,KAAKM,OAAO/C,UAAK,IAAA8C,IAAAA,EAAeL,KAAKK,QACpG,IAAMvI,EAAkBkI,KAAKvC,QAAQkG,cACrCpG,GAAO8C,EAAS,EAAIL,KAAKO,OACzBzI,EAAG+M,UAAYxE,EAAS,SAAW,KACnCvI,EAAGoJ,MAAMhG,SAAW,WACpBpD,EAAGoJ,MAAM5D,KAAOA,EAAO,KACvBxF,EAAGoJ,MAAM3D,IAAMA,EAAM,MAGfwC,EAAAS,UAAAqC,yBAAR,SAAiCjC,GAC/B,IAAMkE,EAAexI,OAAO8E,iBAAiBR,GAC7C,MAAO,CACLiB,OAAQkD,WAAWD,EAAazC,YAChCsC,MAAOI,WAAWD,EAAaE,6CA/HxBjF,GAAoBJ,EAAAsF,kBAAAtF,EAAAuF,+CAApBnF,EAAoBoF,UAAA,CAAA,CAAA,iBAAAC,UAAA,SAAAC,EAAA7I,UAAA,EAAA6I,wiBAf7BnG,EAAAA,WAAAA,EAAAA,EAAAA,EAAAA,EAAAA,cAAAA,KAAAA,EAAAA,EAAAA,wBAGAP,EAAAA,eAAAA,EAAAA,KAAAA,EAAAA,GAEEO,EAAAA,WAAAA,EAAAA,EAAAA,EAAAA,GAAAA,KAAAA,GAOFC,EAAAA,sBAREM,EAAAA,UAAAA,GAAAL,EAAAA,YAAAA,gBAAAA,EAAAA,SAAAA,CAAgC,oBAAA5C,EAAA8C,UAAA9C,EAAA6D,QADxBX,EAAAA,WAAAA,SAAAA,EAAAA,QAEJD,EAAAA,UAAAA,GAAAC,EAAAA,WAAAA,UAAAA,EAAAA,s5BATV,gBCqEE,SAAA4F,EACUC,EACAC,EACAC,GAHV,IAAAC,EAAA1F,KACUA,KAAAuF,SAAAA,EACAvF,KAAAwF,mBAAAA,EACAxF,KAAAyF,kBAAAA,EAzCDzF,KAAA2F,cAA+B,CAAExF,MAAO,IAIzCH,KAAA4F,eAAgC,CACtCzF,MAAO,GACP0F,YAAa,IACb5F,SAAU,QACV6F,UAAW,EACXC,YAAY,EACZC,eAAe,EACf3N,YAAY,EACZ4N,cAAe,SAACnC,EAAW+B,GAAwB,OAAAH,EAAKQ,aAAaL,YAAc/B,EAAK4B,EAAKQ,aAAajG,YAOlGD,KAAAmG,WAAa,IAAIjG,EAAAA,aAGjBF,KAAAoG,aAAe,IAAIlG,EAAAA,aAGnBF,KAAAqG,OAAS,IAAInG,EAAAA,aACbF,KAAAsG,OAAS,IAAIpG,EAAAA,aAEfF,KAAAuG,aAAiD,UAjCzDjD,OAAAC,eAAsB+B,EAAA9E,UAAA,UAAO,KAA7B,SAA8BL,GAC5BH,KAAKwG,aAAerG,mCAgDtBmF,EAAA9E,UAAAiG,YAAA,SAAYC,IAENA,EAAiB,SAAKA,EAAuB,gBAC/C1G,KAAK2G,gBAIFrB,EAAA9E,UAAAmG,aAAP,WAAA,IAAAjB,EAAA1F,KACM4G,EAAS5G,KAAK2F,cAClB3F,KAAKuG,aAAe,GAEhBvG,KAAKwG,eACPI,EAAOzG,MAAQH,KAAKwG,cAEtBxG,KAAK6G,UAAUD,GAEXA,EAAOE,UACTF,EAAOE,SAASpF,SAAQ,SAAAkF,GAAU,OAAAlB,EAAKmB,UAAUD,OAK7CtB,EAAA9E,UAAAqG,UAAR,SAAkBD,GAEhB,IAAIG,EAAWzD,OAAO0D,OAAO,GAAIhH,KAAK4F,gBAGlCzF,GAFJyG,EAAStD,OAAO0D,OAAOD,EAAUH,IAEdzG,MACfA,GAASA,EAAMrH,OAAS,IAEH,iBAAZqH,EAAM,KACfA,EAAQA,EAAM8G,KAAI,SAACC,GACjB,IAAIC,EAAS,GAEb,OADAA,EAAOP,EAAO3G,UAAYiH,EACnBC,MAGPP,EAAO3G,WAETE,EAAQA,EAAMiH,QAAO,SAAAhO,GAAK,OAAAA,EAAEwN,EAAO3G,aAC9B2G,EAAOS,aACVlH,EAAMmH,MAAK,SAACC,EAAGC,GAAM,OAAAD,EAAEX,EAAO3G,UAAUwH,cAAcD,EAAEZ,EAAO3G,gBAIrE2G,EAAOzG,MAAQA,EAGfH,KAAKuG,aAAaK,EAAOf,aAAee,EAGpC5G,KAAKkG,cAAgBlG,KAAKkG,aAAaL,aAAee,EAAOf,cAC/D7F,KAAKkG,aAAeU,EACpB5G,KAAK0H,qBAITpC,EAAA9E,UAAAmH,UAAA,SAAUpP,GACRyH,KAAKzH,OAASA,GAGhB+M,EAAA9E,UAAAoH,UAAA,SAAUC,GAEHA,EAAMC,WACTD,EAAM5I,iBACN4I,EAAME,kBACNF,EAAMG,6BAIV1C,EAAA9E,UAAAyH,YAAA,SAAYJ,GACV7H,KAAK4H,UAAUC,GACf7H,KAAKkI,cAGP5C,EAAA9E,UAAA2H,aAAA,SAAaN,EAAYlE,GACvB,QADuB,IAAAA,IAAAA,EAAkC3D,KAAKuF,SAAS5B,eAlJtD,MAmJb3D,KAAKoI,aAAgCP,EAAMQ,KAAM,CACnD,IAAIC,EAAUT,EAAMQ,KAAKE,WAAW,GACpCvI,KAAKwI,WAAW,CAAEF,QAAOA,EAAEG,YAAY,GAAQ9E,KAKnD2B,EAAA9E,UAAAgI,WAAA,SAAWX,EAAYlE,GAGrB,QAHqB,IAAAA,IAAAA,EAAkC3D,KAAKuF,SAAS5B,eACrE3D,KAAKoI,YAAcP,EAAMS,SAErBT,EAAMa,aA7JO,MA6JQb,EAAMS,QAA/B,CAIA,IAAI3P,EAAcd,EAAS8L,GACvBtI,EAAMK,EAAiBiI,EAAe3D,KAAKzH,QAC3CoQ,EAAcd,EAAMe,IACxB,IAAKD,EAAa,CAChB,IAAIE,EAAWhB,EAAMiB,OAASjB,EAAMS,QAElCK,GADGd,EAAMkB,UAAaF,GAAY,IAAMA,GAAY,GACtCG,OAAOC,aAAaJ,EAAW,IAQ/BG,OAAOC,aAAapB,EAAMiB,OAASjB,EAAMS,SAvL7C,IA0LVT,EAAMS,SAAwBT,EAAMC,UAAYzM,EAAM2E,KAAKkJ,WAE7D7N,EAAM2E,KAAKmJ,UAAUrQ,OACrBC,EAAiBiH,KAAKmJ,UAAW9N,EAAK2E,KAAKzH,SAI7C,IAAIqO,EAAS5G,KAAKuG,aAAaoC,GAC/B,GAAI/B,EACF5G,KAAKkG,aAAeU,EACpB5G,KAAKkJ,SAAWrB,EAAMY,WAAapN,EAAM,EAAIA,EAC7C2E,KAAKmJ,WAAanJ,KAAKzH,OAASyH,KAAKzH,OAAO4D,cAAcE,eAAiBC,OAAOD,gBAAgBzC,WAClGoG,KAAKoJ,WAAY,EACjBpJ,KAAKqJ,aAAe,KACpBrJ,KAAKsJ,eAAe3F,GACpB3D,KAAK0H,mBAEDd,EAAOZ,eACThG,KAAKmG,WAAWpH,KAAK6H,EAAOf,kBAI3B,GAAI7F,KAAKkJ,UAAY,GAAKlJ,KAAKoJ,UAClC,GAAI/N,GAAO2E,KAAKkJ,SACdlJ,KAAKuJ,WAAWnJ,QAAS,OAGtB,GApNO,KAoNHyH,EAAMS,UACZT,EAAM2B,UACN3B,EAAM4B,SACN5B,EAAM6B,SACPrO,EAAM2E,KAAKkJ,SACX,CACA,GAAKlJ,KAAKkG,aAAaH,YAxNb,KAwN2B8B,EAAMS,SAGtC,GAhOS,IAgOLT,EAAMS,SAA6BjN,EAAM,IAChDA,GACW2E,KAAKkJ,UACdlJ,KAAKkI,kBAGJ,IAAKlI,KAAKuJ,WAAWnJ,OAAQ,CAChC,GAtOM,IAsOFyH,EAAMS,SArOF,KAqOyBT,EAAMS,QAAuB,CAC5DtI,KAAK4H,UAAUC,GAEf7H,KAAKoG,aAAarH,KAAKiB,KAAKuJ,WAAWI,YAEvC,IAAMrR,EAAO0H,KAAKkG,aAAaD,cAAcjG,KAAKuJ,WAAWI,WAAY3J,KAAKkG,aAAaL,aAK3F,GAFA3N,EAAYyL,EAAe3D,KAAKkJ,SAAU7N,EAAK2E,KAAKkG,aAAa7N,WAAYC,EAAM0H,KAAKzH,QAEpF,gBAAiB6D,SAAU,CAC7B,IAAIwN,EAAMxN,SAASyN,YAAY,cAC3B7J,KAAKzH,OAEPqR,EAAIE,UAAU,UAAU,GAAM,GAG9BF,EAAIE,UAAU,SAAS,GAAM,GAI/B9J,KAAKuF,SAAS5B,cAAcoG,cAAcH,GAI5C,OAFA5J,KAAKkJ,UAAY,EACjBlJ,KAAKkI,cACE,EAEJ,GA9PI,KA8PAL,EAAMS,QAGb,OAFAtI,KAAK4H,UAAUC,GACf7H,KAAKkI,cACE,EAEJ,GA9PE,KA8PEL,EAAMS,QAGb,OAFAtI,KAAK4H,UAAUC,GACf7H,KAAKuJ,WAAW/F,oBACT,EAEJ,GArQA,KAqQIqE,EAAMS,QAGb,OAFAtI,KAAK4H,UAAUC,GACf7H,KAAKuJ,WAAWlF,wBACT,QAjDTrE,KAAKkJ,UAAY,EAqDnB,GAAwB,GAApBP,EAAY7P,QAnRF,GAmRe+O,EAAMS,QAEjC,OADAtI,KAAK4H,UAAUC,IACR,EAEJ,GAAI7H,KAAKoJ,UAAW,CACvB,IAAIY,EAAUrR,EAAIE,UAAUmH,KAAKkJ,SAAW,EAAG7N,GAK/C,GA7RY,IAyRRwM,EAAMS,SAA8BT,EAAMY,aAC5CuB,GAAWrB,GAEb3I,KAAKqJ,aAAeW,EAChBhK,KAAKkG,aAAaF,cAAe,CACnC,IAAMH,EAAe7F,KAAKqJ,cA9RhB,IA8RgCxB,EAAMS,QAA6B3P,EAAIE,UAAUmH,KAAKkJ,SAAUlJ,KAAKkJ,SAAW,GAAK,GAC/HlJ,KAAKmG,WAAWpH,KAAK8G,EAAc7F,KAAKqJ,mBAGxCrJ,KAAKmG,WAAWpH,KAAKiB,KAAKqJ,cAE5BrJ,KAAK0H,uBAONpC,EAAA9E,UAAAyJ,YAAP,SAAmBpE,EAAsBlC,QAAA,IAAAA,IAAAA,EAAkC3D,KAAKuF,SAAS5B,eACvFkC,EAAcA,GAAe7F,KAAK2F,cAAcE,aAAe7F,KAAK4F,eAAeC,YACnF,IAAMxK,EAAMK,EAAiBiI,EAAe3D,KAAKzH,QACjDL,EAAYyL,EAAetI,EAAKA,EAAK2E,KAAKkG,aAAa7N,WAAYwN,EAAa7F,KAAKzH,QACrFyH,KAAKwI,WAAW,CAAEI,IAAK/C,EAAa4C,YAAY,GAAQ9E,IAG1D2B,EAAA9E,UAAA0H,WAAA,WACMlI,KAAKuJ,aAAevJ,KAAKuJ,WAAWnJ,SACtCJ,KAAKuJ,WAAWnJ,QAAS,EACzBJ,KAAKsG,OAAOvH,QAEdiB,KAAKkG,aAAe,KACpBlG,KAAKoJ,WAAY,GAGnB9D,EAAA9E,UAAAkH,iBAAA,WAAA,IAAAhC,EAAA1F,KACMkK,EAAiB,GACrB,GAAIlK,KAAKkG,cAAgBlG,KAAKkG,aAAa/F,MAAO,CAChD,IAAIgK,EAAUnK,KAAKkG,aAAa/F,MAEhC,IAAKH,KAAKkG,aAAakE,eAAiBpK,KAAKqJ,cAAgBrJ,KAAKkG,aAAajG,SAAU,CACvF,IAAIoK,EAAwBrK,KAAKqJ,aAAaiB,cAC9CH,EAAUA,EAAQ/C,QAAO,SAAAhO,GAAK,OAAAA,EAAEsM,EAAKQ,aAAajG,UAAUqK,cAAcC,WAAWF,MAEvFH,EAAUC,EACNnK,KAAKkG,aAAaJ,SAAW,IAC/BoE,EAAUA,EAAQvO,MAAM,EAAGqE,KAAKkG,aAAaJ,WAI7C9F,KAAKuJ,aACPvJ,KAAKuJ,WAAWpJ,MAAQ+J,EACxBlK,KAAKuJ,WAAWnJ,OAA2B,GAAlB8J,EAAQpR,SAIrCwM,EAAA9E,UAAA8I,eAAA,SAAe3F,GAAf,IAAA+B,EAAA1F,KAGE,GAFAA,KAAKqG,OAAOtH,OAEW,MAAnBiB,KAAKuJ,WAAoB,CAC3B,IAAIiB,EAAmBxK,KAAKwF,mBAAmBiF,wBAAwB1K,GACnE2K,EAAe1K,KAAKyF,kBAAkBkF,gBAAgBH,GAC1DxK,KAAKuJ,WAAamB,EAAaE,SAC/B5K,KAAKuJ,WAAW7I,aAAeV,KAAK6K,oBACpCH,EAAaE,SAAoB,UAAEE,WAAU,WAC3CnH,EAAcpI,QACd,IAAIwP,EAAc,CAAEnC,IAAK,QAASN,QAxVxB,GAwV4CR,UAAU,GAChEpC,EAAK8C,WAAWuC,EAAapH,MAGjC3D,KAAKuJ,WAAWtJ,SAAWD,KAAKkG,aAAajG,SAC7CD,KAAKuJ,WAAWlJ,OAASL,KAAKkG,aAAa7F,OAC3CL,KAAKuJ,WAAWjK,SAAWU,KAAK2F,cAAcqF,aAC9ChL,KAAKuJ,WAAWhK,YAAc,EAC9BS,KAAKuJ,WAAWrO,SAASyI,EAAe3D,KAAKzH,QAC7C+D,OAAO2O,uBAAsB,WAAM,OAAAvF,EAAK6D,WAAW/E,6CAxU1Cc,GAAgB3F,EAAAsF,kBAAAtF,EAAAuF,YAAAvF,EAAAsF,kBAAAtF,EAAAuL,0BAAAvL,EAAAsF,kBAAAtF,EAAAwL,qDAAhB7F,EAAgBH,UAAA,CAAA,CAAA,GAAA,UAAA,IAAA,CAAA,GAAA,gBAAA,KAAAiG,UAAA,CAAA,eAAA,OAAAC,aAAA,SAAAhG,EAAA7I,GAAA,EAAA6I,8CAAhB7I,EAAAgM,WAAAxJ,MAAkB,SAAA,SAAAA,GAAA,OAAlBxC,EAAA2L,aAAAnJ,MAAoB,QAAA,SAAAA,GAAA,OAApBxC,EAAAyL,YAAAjJ,8PC7Bb,SAAAsM,4CAeaA,iEAAAA,IAAaC,QAAA,CAVf,CACPC,EAAAA,uFASSF,EAAa,CAAAG,aAAA,CAbtBnG,EACAvF,GAAoBwL,QAAA,CAGpBC,EAAAA,cAAYE,QAAA,CAGZpG","sourcesContent":["// DOM element manipulation functions...\r\n//\r\n\r\nfunction setValue(el: HTMLInputElement, value: any) {\r\n  //console.log(\"setValue\", el.nodeName, \"[\"+value+\"]\");\r\n  if (isInputOrTextAreaElement(el)) {\r\n    el.value = value;\r\n  }\r\n  else {\r\n    el.textContent = value;\r\n  }\r\n}\r\n\r\nexport function getValue(el: HTMLInputElement) {\r\n  return isInputOrTextAreaElement(el) ? el.value : el.textContent;\r\n}\r\n\r\nexport function insertValue(\r\n  el: HTMLInputElement,\r\n  start: number,\r\n  end: number,\r\n  insertHTML: boolean,\r\n  text: any,\r\n  iframe: HTMLIFrameElement,\r\n  noRecursion: boolean = false\r\n) {\r\n  //console.log(\"insertValue\", el.nodeName, start, end, \"[\"+text+\"]\", el);\r\n  if (isTextElement(el)) {\r\n    let val = getValue(el);\r\n    setValue(el, val.substring(0, start) + text + val.substring(end, val.length));\r\n    setCaretPosition(el, start + text.length, iframe);\r\n  }\r\n  else if (!noRecursion) {\r\n    let selObj: Selection = getWindowSelection(iframe);\r\n    if (selObj && selObj.rangeCount > 0) {\r\n      // var selRange = selObj.getRangeAt(0);\r\n      // var position = selRange.startOffset;\r\n      // var anchorNode = selObj.anchorNode;\r\n      // if (text.endsWith(' ')) {\r\n      //   text = text.substring(0, text.length-1) + '\\xA0';\r\n      // }\r\n      // insertValue(<HTMLInputElement>anchorNode, position - (end - start), position, text, iframe, true);\r\n\r\n      if (insertHTML) {\r\n        insertElement(selObj, start, end, text, iframe);\r\n      }\r\n      else {\r\n        var selRange = selObj.getRangeAt(0);\r\n        var position = selRange.startOffset;\r\n        var anchorNode = selObj.anchorNode;\r\n        // if (text.endsWith(' ')) {\r\n        //   text = text.substring(0, text.length-1) + '\\xA0';\r\n        // }\r\n\r\n        insertValue(<HTMLInputElement>anchorNode, position - (end - start), position, insertHTML, text, iframe, true);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction makeAngularElements(el) {\r\n  if (!(el instanceof HTMLElement)) {\r\n    return;\r\n  }\r\n  el.setAttribute(\"_ngcontent-c0\", '');\r\n  for (let i in el.children) {\r\n    makeAngularElements(el.children[i])\r\n  }\r\n}\r\n\r\nfunction insertElement(\r\n  selObj: Selection,\r\n  start: number,\r\n  end: number,\r\n  text: HTMLElement,\r\n  iframe: HTMLIFrameElement\r\n) {\r\n  if (!(text instanceof HTMLElement)) {\r\n    var e = getDocument(iframe).createElement(\"span\");\r\n    e.innerHTML = text;\r\n    text = e;\r\n  }\r\n\r\n  //make the element an angular element\r\n  makeAngularElements(text);\r\n\r\n  var anchorNode = selObj.anchorNode;\r\n\r\n  //Get the text that preceeded and followed what was typed as part of the autocomplete\r\n  var beforeString = anchorNode.nodeValue.substr(0, start);\r\n  var afterString = anchorNode.nodeValue.substring(end);\r\n\r\n   //console.log(\"beforeString:\",beforeString);\r\n   //console.log(\"afterString:\",afterString);\r\n\r\n //removing previous typed search string\r\n var positionChar = beforeString.lastIndexOf('@');\r\n\r\n //console.log(\" positionChar:\", positionChar);\r\n\r\n if(positionChar < 0) {\r\n  beforeString = beforeString + '@';\r\n  var positionChar = beforeString.lastIndexOf('@');\r\n  //console.log(\" beforeString 2:\", beforeString);\r\n}\r\n\r\n\r\n beforeString = beforeString.substring(0,  positionChar + 1);\r\n //console.log(\"beforeString final:\",beforeString);\r\n\r\n  //Remove the text\r\n  anchorNode.nodeValue = \"\";\r\n\r\n  //Create spans for the preceeding text & following text\r\n  let beforeEl = getDocument(iframe).createElement(\"span\");\r\n  beforeEl.innerText = beforeString;\r\n  let afterEl = getDocument(iframe).createElement(\"span\");\r\n  afterEl.innerText = afterString;\r\n\r\n  //Insert the spans + the mention element\r\n  anchorNode.parentNode.insertBefore(afterEl, anchorNode.nextSibling);\r\n  anchorNode.parentNode.insertBefore(text, anchorNode.nextSibling);\r\n  anchorNode.parentNode.insertBefore(beforeEl, anchorNode.nextSibling);\r\n\r\n  //Create a range located ater the mention\r\n  let range = getDocument(iframe).createRange();\r\n  range.selectNode(afterEl);\r\n  range.setStart(afterEl, 0);\r\n  range.setEnd(afterEl, 0);\r\n\r\n  //Move the cursor to that spot\r\n  range.collapse(false);\r\n  selObj.removeAllRanges();\r\n  selObj.addRange(range);\r\n}\r\n\r\nexport function isInputOrTextAreaElement(el: HTMLElement): boolean {\r\n  return el != null && (el.nodeName == 'INPUT' || el.nodeName == 'TEXTAREA');\r\n};\r\n\r\nexport function isTextElement(el: HTMLElement): boolean {\r\n  return el != null && (el.nodeName == 'INPUT' || el.nodeName == 'TEXTAREA' || el.nodeName == '#text');\r\n};\r\n\r\nexport function setCaretPosition(el: HTMLInputElement, pos: number, iframe: HTMLIFrameElement = null) {\r\n  //console.log(\"setCaretPosition\", pos, el, iframe==null);\r\n  if (isInputOrTextAreaElement(el) && el.selectionStart) {\r\n    el.focus();\r\n    el.setSelectionRange(pos, pos);\r\n  }\r\n  else {\r\n    let range = getDocument(iframe).createRange();\r\n    range.setStart(el, pos);\r\n    range.collapse(true);\r\n    let sel = getWindowSelection(iframe);\r\n    sel.removeAllRanges();\r\n    sel.addRange(range);\r\n  }\r\n}\r\n\r\nexport function getCaretPosition(el: HTMLInputElement, iframe: HTMLIFrameElement = null) {\r\n  //console.log(\"getCaretPosition\", el);\r\n  if (isInputOrTextAreaElement(el)) {\r\n    var val = el.value;\r\n    return val.slice(0, el.selectionStart).length;\r\n  }\r\n  else {\r\n    var selObj = getWindowSelection(iframe); //window.getSelection();\r\n    if (selObj.rangeCount > 0) {\r\n      var selRange = selObj.getRangeAt(0);\r\n      var preCaretRange = selRange.cloneRange();\r\n      preCaretRange.selectNodeContents(el);\r\n      preCaretRange.setEnd(selRange.endContainer, selRange.endOffset);\r\n      var position = preCaretRange.toString().length;\r\n      return position;\r\n    }\r\n  }\r\n}\r\n\r\n// Based on ment.io functions...\r\n//\r\n\r\nfunction getDocument(iframe: HTMLIFrameElement) {\r\n  if (!iframe) {\r\n    return document;\r\n  } else {\r\n    return iframe.contentWindow.document;\r\n  }\r\n}\r\n\r\nfunction getWindowSelection(iframe: HTMLIFrameElement): Selection {\r\n  if (!iframe) {\r\n    return window.getSelection();\r\n  } else {\r\n    return iframe.contentWindow.getSelection();\r\n  }\r\n}\r\n\r\nexport function getContentEditableCaretCoords(ctx: { iframe: HTMLIFrameElement, parent?: Element }) {\r\n  let markerTextChar = '\\ufeff';\r\n  let markerId = 'sel_' + new Date().getTime() + '_' + Math.random().toString().substr(2);\r\n  let doc = getDocument(ctx ? ctx.iframe : null);\r\n  let sel = getWindowSelection(ctx ? ctx.iframe : null);\r\n  let prevRange = sel.getRangeAt(0);\r\n\r\n  // create new range and set postion using prevRange\r\n  let range = doc.createRange();\r\n  range.setStart(sel.anchorNode, prevRange.startOffset);\r\n  range.setEnd(sel.anchorNode, prevRange.startOffset);\r\n  range.collapse(false);\r\n\r\n  // Create the marker element containing a single invisible character\r\n  // using DOM methods and insert it at the position in the range\r\n  let markerEl = doc.createElement('span');\r\n  markerEl.id = markerId;\r\n  markerEl.appendChild(doc.createTextNode(markerTextChar));\r\n  range.insertNode(markerEl);\r\n  sel.removeAllRanges();\r\n  sel.addRange(prevRange);\r\n\r\n  let coordinates = {\r\n    left: 0,\r\n    top: markerEl.offsetHeight\r\n  };\r\n\r\n  localToRelativeCoordinates(ctx, markerEl, coordinates);\r\n\r\n  markerEl.parentNode.removeChild(markerEl);\r\n  return coordinates;\r\n}\r\n\r\nfunction localToRelativeCoordinates(\r\n  ctx: { iframe: HTMLIFrameElement, parent?: Element },\r\n  element: Element,\r\n  coordinates: { top: number; left: number }\r\n) {\r\n  let obj = <HTMLElement>element;\r\n  let iframe = ctx ? ctx.iframe : null;\r\n  while (obj) {\r\n    if (ctx.parent != null && ctx.parent == obj) {\r\n      break;\r\n    }\r\n    coordinates.left += obj.offsetLeft + obj.clientLeft;\r\n    coordinates.top += obj.offsetTop + obj.clientTop;\r\n    obj = <HTMLElement>obj.offsetParent;\r\n    if (!obj && iframe) {\r\n      obj = iframe;\r\n      iframe = null;\r\n    }\r\n  }\r\n  obj = <HTMLElement>element;\r\n  iframe = ctx ? ctx.iframe : null;\r\n  while (obj !== getDocument(null).body && obj != null) {\r\n    if (ctx.parent != null && ctx.parent == obj) {\r\n      break;\r\n    }\r\n    if (obj.scrollTop && obj.scrollTop > 0) {\r\n      coordinates.top -= obj.scrollTop;\r\n    }\r\n    if (obj.scrollLeft && obj.scrollLeft > 0) {\r\n      coordinates.left -= obj.scrollLeft;\r\n    }\r\n    obj = <HTMLElement>obj.parentNode;\r\n    if (!obj && iframe) {\r\n      obj = iframe;\r\n      iframe = null;\r\n    }\r\n  }\r\n}\r\n","/* From: https://github.com/component/textarea-caret-position */\r\n/* jshint browser: true */\r\n\r\n// (function () {\r\n\r\n  // We'll copy the properties below into the mirror div.\r\n  // Note that some browsers, such as Firefox, do not concatenate properties\r\n  // into their shorthand (e.g. padding-top, padding-bottom etc. -> padding),\r\n  // so we have to list every single property explicitly.\r\n  var properties = [\r\n    'direction',  // RTL support\r\n    'boxSizing',\r\n    'width',  // on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does\r\n    'height',\r\n    'overflowX',\r\n    'overflowY',  // copy the scrollbar for IE\r\n\r\n    'borderTopWidth',\r\n    'borderRightWidth',\r\n    'borderBottomWidth',\r\n    'borderLeftWidth',\r\n    'borderStyle',\r\n\r\n    'paddingTop',\r\n    'paddingRight',\r\n    'paddingBottom',\r\n    'paddingLeft',\r\n\r\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/font\r\n    'fontStyle',\r\n    'fontVariant',\r\n    'fontWeight',\r\n    'fontStretch',\r\n    'fontSize',\r\n    'fontSizeAdjust',\r\n    'lineHeight',\r\n    'fontFamily',\r\n\r\n    'textAlign',\r\n    'textTransform',\r\n    'textIndent',\r\n    'textDecoration',  // might not make a difference, but better be safe\r\n\r\n    'letterSpacing',\r\n    'wordSpacing',\r\n\r\n    'tabSize',\r\n    'MozTabSize'\r\n\r\n  ];\r\n\r\n  var isBrowser = (typeof window !== 'undefined');\r\n  var isFirefox = (isBrowser && window['mozInnerScreenX'] != null);\r\n\r\n  export function getCaretCoordinates(element, position, options) {\r\n    if (!isBrowser) {\r\n      throw new Error('textarea-caret-position#getCaretCoordinates should only be called in a browser');\r\n    }\r\n\r\n    var debug = options && options.debug || false;\r\n    if (debug) {\r\n      var el = document.querySelector('#input-textarea-caret-position-mirror-div');\r\n      if (el) el.parentNode.removeChild(el);\r\n    }\r\n\r\n    // The mirror div will replicate the textarea's style\r\n    var div = document.createElement('div');\r\n    div.id = 'input-textarea-caret-position-mirror-div';\r\n    document.body.appendChild(div);\r\n\r\n    var style = div.style;\r\n    var computed = window.getComputedStyle ? window.getComputedStyle(element) : element.currentStyle;  // currentStyle for IE < 9\r\n    var isInput = element.nodeName === 'INPUT';\r\n\r\n    // Default textarea styles\r\n    style.whiteSpace = 'pre-wrap';\r\n    if (!isInput)\r\n      style.wordWrap = 'break-word';  // only for textarea-s\r\n\r\n    // Position off-screen\r\n    style.position = 'absolute';  // required to return coordinates properly\r\n    if (!debug)\r\n      style.visibility = 'hidden';  // not 'display: none' because we want rendering\r\n\r\n    // Transfer the element's properties to the div\r\n    properties.forEach(function (prop) {\r\n      if (isInput && prop === 'lineHeight') {\r\n        // Special case for <input>s because text is rendered centered and line height may be != height\r\n        if (computed.boxSizing === \"border-box\") {\r\n          var height = parseInt(computed.height);\r\n          var outerHeight =\r\n            parseInt(computed.paddingTop) +\r\n            parseInt(computed.paddingBottom) +\r\n            parseInt(computed.borderTopWidth) +\r\n            parseInt(computed.borderBottomWidth);\r\n          var targetHeight = outerHeight + parseInt(computed.lineHeight);\r\n          if (height > targetHeight) {\r\n            style.lineHeight = height - outerHeight + \"px\";\r\n          } else if (height === targetHeight) {\r\n            style.lineHeight = computed.lineHeight;\r\n          } else {\r\n            style.lineHeight = '0';\r\n          }\r\n        } else {\r\n          style.lineHeight = computed.height;\r\n        }\r\n      } else {\r\n        style[prop] = computed[prop];\r\n      }\r\n    });\r\n\r\n    if (isFirefox) {\r\n      // Firefox lies about the overflow property for textareas: https://bugzilla.mozilla.org/show_bug.cgi?id=984275\r\n      if (element.scrollHeight > parseInt(computed.height))\r\n        style.overflowY = 'scroll';\r\n    } else {\r\n      style.overflow = 'hidden';  // for Chrome to not render a scrollbar; IE keeps overflowY = 'scroll'\r\n    }\r\n\r\n    div.textContent = element.value.substring(0, position);\r\n    // The second special handling for input type=\"text\" vs textarea:\r\n    // spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037\r\n    if (isInput)\r\n      div.textContent = div.textContent.replace(/\\s/g, '\\u00a0');\r\n\r\n    var span = document.createElement('span');\r\n    // Wrapping must be replicated *exactly*, including when a long word gets\r\n    // onto the next line, with whitespace at the end of the line before (#7).\r\n    // The  *only* reliable way to do that is to copy the *entire* rest of the\r\n    // textarea's content into the <span> created at the caret position.\r\n    // For inputs, just '.' would be enough, but no need to bother.\r\n    span.textContent = element.value.substring(position) || '.';  // || because a completely empty faux span doesn't render at all\r\n    div.appendChild(span);\r\n\r\n    var coordinates = {\r\n      top: span.offsetTop + parseInt(computed['borderTopWidth']),\r\n      left: span.offsetLeft + parseInt(computed['borderLeftWidth']),\r\n      height: parseInt(computed['lineHeight'])\r\n    };\r\n\r\n    if (debug) {\r\n      span.style.backgroundColor = '#aaa';\r\n    } else {\r\n      document.body.removeChild(div);\r\n    }\r\n\r\n    return coordinates;\r\n  }\r\n\r\n  // if (typeof module != 'undefined' && typeof module.exports != 'undefined') {\r\n  //   module.exports = getCaretCoordinates;\r\n  // } else if(isBrowser) {\r\n  //   window.getCaretCoordinates = getCaretCoordinates;\r\n  // }\r\n\r\n  // }());","import {\r\n  Component, ElementRef, Output, EventEmitter, ViewChild, Input, TemplateRef, AfterContentChecked\r\n} from '@angular/core';\r\n\r\nimport { isInputOrTextAreaElement, getContentEditableCaretCoords } from './mention-utils';\r\nimport { getCaretCoordinates } from './caret-coords';\r\n\r\n/**\r\n * Angular Mentions.\r\n * https://github.com/dmacfarlane/angular-mentions\r\n *\r\n * Copyright (c) 2016 Dan MacFarlane\r\n */\r\n@Component({\r\n  selector: 'mention-list',\r\n  styleUrls: ['./mention-list.component.scss'],\r\n  template: `\r\n    <ng-template #defaultItemTemplate let-item=\"item\">\r\n      {{item[labelKey]}}\r\n    </ng-template>\r\n    <ul #list [hidden]=\"hidden\" class=\"dropdown-menu scrollable-menu\"\r\n      [class.mention-menu]=\"!styleOff\" [class.mention-dropdown]=\"!styleOff && dropUp\">\r\n      <li *ngFor=\"let item of items; let i = index\"\r\n        [class.active]=\"activeIndex==i\" [class.mention-active]=\"!styleOff && activeIndex==i\">\r\n        <a class=\"dropdown-item\" [class.mention-item]=\"!styleOff\"\r\n          (mousedown)=\"activeIndex=i;itemClick.emit();$event.preventDefault()\">\r\n          <ng-template [ngTemplateOutlet]=\"itemTemplate\" [ngTemplateOutletContext]=\"{'item':item}\"></ng-template>\r\n        </a>\r\n      </li>\r\n    </ul>\r\n    `\r\n})\r\nexport class MentionListComponent implements AfterContentChecked {\r\n  @Input() labelKey: string = 'label';\r\n  @Input() itemTemplate: TemplateRef<any>;\r\n  @Output() itemClick = new EventEmitter();\r\n  @ViewChild('list', { static: true }) list: ElementRef;\r\n  @ViewChild('defaultItemTemplate', { static: true }) defaultItemTemplate: TemplateRef<any>;\r\n  items = [];\r\n  activeIndex: number = 0;\r\n  hidden: boolean = false;\r\n  dropUp: boolean = false;\r\n  styleOff: boolean = false;\r\n  private coords: {top:number, left:number} = {top:0, left:0};\r\n  private offset: number = 0;\r\n  constructor(private element: ElementRef) {}\r\n\r\n  ngAfterContentChecked() {\r\n    if (!this.itemTemplate) {\r\n      this.itemTemplate = this.defaultItemTemplate;\r\n    }\r\n  }\r\n\r\n  // lots of confusion here between relative coordinates and containers\r\n  position(nativeParentElement: HTMLInputElement, iframe: HTMLIFrameElement = null) {\r\n    if (isInputOrTextAreaElement(nativeParentElement)) {\r\n      // parent elements need to have postition:relative for this to work correctly?\r\n      this.coords = getCaretCoordinates(nativeParentElement, nativeParentElement.selectionStart, null);\r\n      this.coords.top = nativeParentElement.offsetTop + this.coords.top - nativeParentElement.scrollTop;\r\n      this.coords.left = nativeParentElement.offsetLeft + this.coords.left - nativeParentElement.scrollLeft;\r\n      // getCretCoordinates() for text/input elements needs an additional offset to position the list correctly\r\n      this.offset = this.getBlockCursorDimensions(nativeParentElement).height;\r\n    }\r\n    else if (iframe) {\r\n      let context: { iframe: HTMLIFrameElement, parent: Element } = { iframe: iframe, parent: iframe.offsetParent };\r\n      this.coords = getContentEditableCaretCoords(context);\r\n    }\r\n    else {\r\n      let doc = document.documentElement;\r\n      let scrollLeft = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\r\n      let scrollTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\r\n      // bounding rectangles are relative to view, offsets are relative to container?\r\n      let caretRelativeToView = getContentEditableCaretCoords({ iframe: iframe });\r\n      let parentRelativeToContainer: ClientRect = nativeParentElement.getBoundingClientRect();\r\n      this.coords.top = caretRelativeToView.top - parentRelativeToContainer.top + nativeParentElement.offsetTop - scrollTop;\r\n      this.coords.left = caretRelativeToView.left - parentRelativeToContainer.left + nativeParentElement.offsetLeft - scrollLeft;\r\n    }\r\n    // set the default/inital position\r\n    this.positionElement();\r\n  }\r\n\r\n  get activeItem() {\r\n    return this.items[this.activeIndex];\r\n  }\r\n\r\n  activateNextItem() {\r\n    // adjust scrollable-menu offset if the next item is out of view\r\n    let listEl: HTMLElement = this.list.nativeElement;\r\n    let activeEl = listEl.getElementsByClassName('active').item(0);\r\n    if (activeEl) {\r\n      let nextLiEl: HTMLElement = <HTMLElement> activeEl.nextSibling;\r\n      if (nextLiEl && nextLiEl.nodeName == \"LI\") {\r\n        let nextLiRect: ClientRect = nextLiEl.getBoundingClientRect();\r\n        if (nextLiRect.bottom > listEl.getBoundingClientRect().bottom) {\r\n          listEl.scrollTop = nextLiEl.offsetTop + nextLiRect.height - listEl.clientHeight;\r\n        }\r\n      }\r\n    }\r\n    // select the next item\r\n    this.activeIndex = Math.max(Math.min(this.activeIndex + 1, this.items.length - 1), 0);\r\n  }\r\n\r\n  activatePreviousItem() {\r\n    // adjust the scrollable-menu offset if the previous item is out of view\r\n    let listEl: HTMLElement = this.list.nativeElement;\r\n    let activeEl = listEl.getElementsByClassName('active').item(0);\r\n    if (activeEl) {\r\n      let prevLiEl: HTMLElement = <HTMLElement> activeEl.previousSibling;\r\n      if (prevLiEl && prevLiEl.nodeName == \"LI\") {\r\n        let prevLiRect: ClientRect = prevLiEl.getBoundingClientRect();\r\n        if (prevLiRect.top < listEl.getBoundingClientRect().top) {\r\n          listEl.scrollTop = prevLiEl.offsetTop;\r\n        }\r\n      }\r\n    }\r\n    // select the previous item\r\n    this.activeIndex = Math.max(Math.min(this.activeIndex - 1, this.items.length - 1), 0);\r\n  }\r\n\r\n  // reset for a new mention search\r\n  reset() {\r\n    this.list.nativeElement.scrollTop = 0;\r\n    this.checkBounds();\r\n  }\r\n\r\n  // final positioning is done after the list is shown (and the height and width are known)\r\n  // ensure it's in the page bounds\r\n  private checkBounds() {\r\n    let left = this.coords.left, top = this.coords.top, dropUp = this.dropUp;\r\n    const bounds: ClientRect = this.list.nativeElement.getBoundingClientRect();\r\n    // if off right of page, align right\r\n    if (bounds.left + bounds.width > window.innerWidth) {\r\n      left -= bounds.left + bounds.width - window.innerWidth + 10;\r\n    }\r\n    // if more than half off the bottom of the page, force dropUp\r\n    // if ((bounds.top+bounds.height/2)>window.innerHeight) {\r\n    //   dropUp = true;\r\n    // }\r\n    // if top is off page, disable dropUp\r\n    if (bounds.top<0) {\r\n      dropUp = false;\r\n    }\r\n    // set the revised/final position\r\n    this.positionElement(left, top, dropUp);\r\n  }\r\n\r\n  private positionElement(left:number=this.coords.left, top:number=this.coords.top, dropUp:boolean=this.dropUp) {\r\n    const el: HTMLElement = this.element.nativeElement;\r\n    top += dropUp ? 0 : this.offset; // top of list is next line\r\n    el.className = dropUp ? 'dropup' : null;\r\n    el.style.position = \"absolute\";\r\n    el.style.left = left + 'px';\r\n    el.style.top = top + 'px';\r\n  }\r\n\r\n  private getBlockCursorDimensions(nativeParentElement: HTMLInputElement) {\r\n    const parentStyles = window.getComputedStyle(nativeParentElement);\r\n    return {\r\n      height: parseFloat(parentStyles.lineHeight),\r\n      width: parseFloat(parentStyles.fontSize)\r\n    };\r\n  }\r\n}\r\n","import { ComponentFactoryResolver, Directive, ElementRef, TemplateRef, ViewContainerRef } from \"@angular/core\";\r\nimport { EventEmitter, Input, OnChanges, Output, SimpleChanges } from \"@angular/core\";\r\nimport { getCaretPosition, getValue, insertValue, setCaretPosition } from './mention-utils';\r\n\r\nimport { MentionConfig } from \"./mention-config\";\r\nimport { MentionListComponent } from './mention-list.component';\r\n\r\nconst KEY_BACKSPACE = 8;\r\nconst KEY_TAB = 9;\r\nconst KEY_ENTER = 13;\r\nconst KEY_SHIFT = 16;\r\nconst KEY_ESCAPE = 27;\r\nconst KEY_SPACE = 32;\r\nconst KEY_LEFT = 37;\r\nconst KEY_UP = 38;\r\nconst KEY_RIGHT = 39;\r\nconst KEY_DOWN = 40;\r\nconst KEY_BUFFERED = 229;\r\n\r\n/**\r\n * Angular Mentions.\r\n * https://github.com/dmacfarlane/angular-mentions\r\n *\r\n * Copyright (c) 2017 Dan MacFarlane\r\n */\r\n@Directive({\r\n  selector: '[mention], [mentionConfig]',\r\n  host: {\r\n    '(keydown)': 'keyHandler($event)',\r\n    '(input)': 'inputHandler($event)',\r\n    '(blur)': 'blurHandler($event)',\r\n    'autocomplete': 'off'\r\n  }\r\n})\r\nexport class MentionDirective implements OnChanges {\r\n\r\n  // stores the items passed to the mentions directive and used to populate the root items in mentionConfig\r\n  private mentionItems: any[];\r\n\r\n  @Input('mention') set mention(items: any[]) {\r\n    this.mentionItems = items;\r\n  }\r\n\r\n  // the provided configuration object\r\n  @Input() mentionConfig: MentionConfig = { items: [] };\r\n\r\n  private activeConfig: MentionConfig;\r\n\r\n  private DEFAULT_CONFIG: MentionConfig = {\r\n    items: [],\r\n    triggerChar: '@',\r\n    labelKey: 'label',\r\n    maxItems: -1,\r\n    allowSpace: false,\r\n    returnTrigger: false,\r\n    insertHTML: true,\r\n    mentionSelect: (item: any, triggerChar?:string) => this.activeConfig.triggerChar + item[this.activeConfig.labelKey]\r\n  }\r\n\r\n  // template to use for rendering list items\r\n  @Input() mentionListTemplate: TemplateRef<any>;\r\n\r\n  // event emitted whenever the search term changes\r\n  @Output() searchTerm = new EventEmitter<string>();\r\n\r\n  // event emitted when an item is selected\r\n  @Output() itemSelected = new EventEmitter<any>();\r\n\r\n  // event emitted whenever the mention list is opened or closed\r\n  @Output() opened = new EventEmitter();\r\n  @Output() closed = new EventEmitter();\r\n\r\n  private triggerChars: { [key: string]: MentionConfig } = {};\r\n\r\n  private searchString: string;\r\n  private startPos: number;\r\n  private startNode;\r\n  private searchList: MentionListComponent;\r\n  private searching: boolean;\r\n  private iframe: any; // optional\r\n  private lastKeyCode: number;\r\n\r\n  constructor(\r\n    private _element: ElementRef,\r\n    private _componentResolver: ComponentFactoryResolver,\r\n    private _viewContainerRef: ViewContainerRef\r\n  ) { }\r\n\r\n  ngOnChanges(changes: SimpleChanges) {\r\n    // console.log('config change', changes);\r\n    if (changes['mention'] || changes['mentionConfig']) {\r\n      this.updateConfig();\r\n    }\r\n  }\r\n\r\n  public updateConfig() {\r\n    let config = this.mentionConfig;\r\n    this.triggerChars = {};\r\n    // use items from directive if they have been set\r\n    if (this.mentionItems) {\r\n      config.items = this.mentionItems;\r\n    }\r\n    this.addConfig(config);\r\n    // nested configs\r\n    if (config.mentions) {\r\n      config.mentions.forEach(config => this.addConfig(config));\r\n    }\r\n  }\r\n\r\n  // add configuration for a trigger char\r\n  private addConfig(config: MentionConfig) {\r\n    // defaults\r\n    let defaults = Object.assign({}, this.DEFAULT_CONFIG);\r\n    config = Object.assign(defaults, config);\r\n    // items\r\n    let items = config.items;\r\n    if (items && items.length > 0) {\r\n      // convert strings to objects\r\n      if (typeof items[0] == 'string') {\r\n        items = items.map((label) => {\r\n          let object = {};\r\n          object[config.labelKey] = label;\r\n          return object;\r\n        });\r\n      }\r\n      if (config.labelKey) {\r\n        // remove items without an labelKey (as it's required to filter the list)\r\n        items = items.filter(e => e[config.labelKey]);\r\n        if (!config.disableSort) {\r\n          items.sort((a, b) => a[config.labelKey].localeCompare(b[config.labelKey]));\r\n        }\r\n      }\r\n    }\r\n    config.items = items;\r\n\r\n    // add the config\r\n    this.triggerChars[config.triggerChar] = config;\r\n\r\n    // for async update while menu/search is active\r\n    if (this.activeConfig && this.activeConfig.triggerChar == config.triggerChar) {\r\n      this.activeConfig = config;\r\n      this.updateSearchList();\r\n    }\r\n  }\r\n\r\n  setIframe(iframe: HTMLIFrameElement) {\r\n    this.iframe = iframe;\r\n  }\r\n\r\n  stopEvent(event: any) {\r\n    //if (event instanceof KeyboardEvent) { // does not work for iframe\r\n    if (!event.wasClick) {\r\n      event.preventDefault();\r\n      event.stopPropagation();\r\n      event.stopImmediatePropagation();\r\n    }\r\n  }\r\n\r\n  blurHandler(event: any) {\r\n    this.stopEvent(event);\r\n    this.stopSearch();\r\n  }\r\n\r\n  inputHandler(event: any, nativeElement: HTMLInputElement = this._element.nativeElement) {\r\n    if (this.lastKeyCode === KEY_BUFFERED && event.data) {\r\n      let keyCode = event.data.charCodeAt(0);\r\n      this.keyHandler({ keyCode, inputEvent: true }, nativeElement);\r\n    }\r\n  }\r\n\r\n  // @param nativeElement is the alternative text element in an iframe scenario\r\n  keyHandler(event: any, nativeElement: HTMLInputElement = this._element.nativeElement) {\r\n    this.lastKeyCode = event.keyCode;\r\n\r\n    if (event.isComposing || event.keyCode === KEY_BUFFERED) {\r\n      return;\r\n    }\r\n\r\n    let val: string = getValue(nativeElement);\r\n    let pos = getCaretPosition(nativeElement, this.iframe);\r\n    let charPressed = event.key;\r\n    if (!charPressed) {\r\n      let charCode = event.which || event.keyCode;\r\n      if (!event.shiftKey && (charCode >= 65 && charCode <= 90)) {\r\n        charPressed = String.fromCharCode(charCode + 32);\r\n      }\r\n      // else if (event.shiftKey && charCode === KEY_2) {\r\n      //   charPressed = this.config.triggerChar;\r\n      // }\r\n      else {\r\n        // TODO (dmacfarlane) fix this for non-alpha keys\r\n        // http://stackoverflow.com/questions/2220196/how-to-decode-character-pressed-from-jquerys-keydowns-event-handler?lq=1\r\n        charPressed = String.fromCharCode(event.which || event.keyCode);\r\n      }\r\n    }\r\n    if (event.keyCode == KEY_ENTER && event.wasClick && pos < this.startPos) {\r\n      // put caret back in position prior to contenteditable menu click\r\n      pos = this.startNode.length;\r\n      setCaretPosition(this.startNode, pos, this.iframe);\r\n    }\r\n    //console.log(\"keyHandler\", this.startPos, pos, val, charPressed, event);\r\n\r\n    let config = this.triggerChars[charPressed];\r\n    if (config) {\r\n      this.activeConfig = config;\r\n      this.startPos = event.inputEvent ? pos - 1 : pos;\r\n      this.startNode = (this.iframe ? this.iframe.contentWindow.getSelection() : window.getSelection()).anchorNode;\r\n      this.searching = true;\r\n      this.searchString = null;\r\n      this.showSearchList(nativeElement);\r\n      this.updateSearchList();\r\n\r\n      if (config.returnTrigger) {\r\n        this.searchTerm.emit(config.triggerChar);\r\n      }\r\n\r\n    }\r\n    else if (this.startPos >= 0 && this.searching) {\r\n      if (pos <= this.startPos) {\r\n        this.searchList.hidden = true;\r\n      }\r\n      // ignore shift when pressed alone, but not when used with another key\r\n      else if (event.keyCode !== KEY_SHIFT &&\r\n        !event.metaKey &&\r\n        !event.altKey &&\r\n        !event.ctrlKey &&\r\n        pos > this.startPos\r\n      ) {\r\n        if (!this.activeConfig.allowSpace && event.keyCode === KEY_SPACE) {\r\n          this.startPos = -1;\r\n        }\r\n        else if (event.keyCode === KEY_BACKSPACE && pos > 0) {\r\n          pos--;\r\n          if (pos == this.startPos) {\r\n            this.stopSearch();\r\n          }\r\n        }\r\n        else if (!this.searchList.hidden) {\r\n          if (event.keyCode === KEY_TAB || event.keyCode === KEY_ENTER) {\r\n            this.stopEvent(event);\r\n            // emit the selected list item\r\n            this.itemSelected.emit(this.searchList.activeItem);\r\n            // optional function to format the selected item before inserting the text\r\n            const text = this.activeConfig.mentionSelect(this.searchList.activeItem, this.activeConfig.triggerChar);\r\n            // value is inserted without a trailing space for consistency\r\n            // between element types (div and iframe do not preserve the space)\r\n            insertValue(nativeElement, this.startPos, pos, this.activeConfig.insertHTML, text, this.iframe);\r\n            // fire input event so angular bindings are updated\r\n            if (\"createEvent\" in document) {\r\n              let evt = document.createEvent(\"HTMLEvents\");\r\n              if (this.iframe) {\r\n                // a 'change' event is required to trigger tinymce updates\r\n                evt.initEvent(\"change\", true, false);\r\n              }\r\n              else {\r\n                evt.initEvent(\"input\", true, false);\r\n              }\r\n              // this seems backwards, but fire the event from this elements nativeElement (not the\r\n              // one provided that may be in an iframe, as it won't be propogate)\r\n              this._element.nativeElement.dispatchEvent(evt);\r\n            }\r\n            this.startPos = -1;\r\n            this.stopSearch();\r\n            return false;\r\n          }\r\n          else if (event.keyCode === KEY_ESCAPE) {\r\n            this.stopEvent(event);\r\n            this.stopSearch();\r\n            return false;\r\n          }\r\n          else if (event.keyCode === KEY_DOWN) {\r\n            this.stopEvent(event);\r\n            this.searchList.activateNextItem();\r\n            return false;\r\n          }\r\n          else if (event.keyCode === KEY_UP) {\r\n            this.stopEvent(event);\r\n            this.searchList.activatePreviousItem();\r\n            return false;\r\n          }\r\n        }\r\n\r\n        if (charPressed.length!=1 && event.keyCode!=KEY_BACKSPACE) {\r\n          this.stopEvent(event);\r\n          return false;\r\n        }\r\n        else if (this.searching) {\r\n          let mention = val.substring(this.startPos + 1, pos);\r\n          if (event.keyCode !== KEY_BACKSPACE && !event.inputEvent) {\r\n            mention += charPressed;\r\n          }\r\n          this.searchString = mention;\r\n          if (this.activeConfig.returnTrigger) {\r\n            const triggerChar = (this.searchString || event.keyCode === KEY_BACKSPACE) ? val.substring(this.startPos, this.startPos + 1) : '';\r\n            this.searchTerm.emit(triggerChar + this.searchString);\r\n          } \r\n          else {\r\n            this.searchTerm.emit(this.searchString);\r\n          }\r\n          this.updateSearchList();\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // exposed for external calls to open the mention list, e.g. by clicking a button\r\n  public startSearch(triggerChar?: string, nativeElement: HTMLInputElement = this._element.nativeElement) {\r\n    triggerChar = triggerChar || this.mentionConfig.triggerChar || this.DEFAULT_CONFIG.triggerChar;\r\n    const pos = getCaretPosition(nativeElement, this.iframe);\r\n    insertValue(nativeElement, pos, pos, this.activeConfig.insertHTML, triggerChar, this.iframe);\r\n    this.keyHandler({ key: triggerChar, inputEvent: true }, nativeElement);\r\n  }\r\n\r\n  stopSearch() {\r\n    if (this.searchList && !this.searchList.hidden) {\r\n      this.searchList.hidden = true;\r\n      this.closed.emit();\r\n    }\r\n    this.activeConfig = null;\r\n    this.searching = false;\r\n  }\r\n\r\n  updateSearchList() {\r\n    let matches: any[] = [];\r\n    if (this.activeConfig && this.activeConfig.items) {\r\n      let objects = this.activeConfig.items;\r\n      // disabling the search relies on the async operation to do the filtering\r\n      if (!this.activeConfig.disableSearch && this.searchString && this.activeConfig.labelKey) {\r\n        let searchStringLowerCase = this.searchString.toLowerCase();\r\n        objects = objects.filter(e => e[this.activeConfig.labelKey].toLowerCase().startsWith(searchStringLowerCase));\r\n      }\r\n      matches = objects;\r\n      if (this.activeConfig.maxItems > 0) {\r\n        matches = matches.slice(0, this.activeConfig.maxItems);\r\n      }\r\n    }\r\n    // update the search list\r\n    if (this.searchList) {\r\n      this.searchList.items = matches;\r\n      this.searchList.hidden = matches.length == 0;\r\n    }\r\n  }\r\n\r\n  showSearchList(nativeElement: HTMLInputElement) {\r\n    this.opened.emit();\r\n\r\n    if (this.searchList == null) {\r\n      let componentFactory = this._componentResolver.resolveComponentFactory(MentionListComponent);\r\n      let componentRef = this._viewContainerRef.createComponent(componentFactory);\r\n      this.searchList = componentRef.instance;\r\n      this.searchList.itemTemplate = this.mentionListTemplate;\r\n      componentRef.instance['itemClick'].subscribe(() => {\r\n        nativeElement.focus();\r\n        let fakeKeydown = { key: 'Enter', keyCode: KEY_ENTER, wasClick: true };\r\n        this.keyHandler(fakeKeydown, nativeElement);\r\n      });\r\n    }\r\n    this.searchList.labelKey = this.activeConfig.labelKey;\r\n    this.searchList.dropUp = this.activeConfig.dropUp;\r\n    this.searchList.styleOff = this.mentionConfig.disableStyle;\r\n    this.searchList.activeIndex = 0;\r\n    this.searchList.position(nativeElement, this.iframe);\r\n    window.requestAnimationFrame(() => this.searchList.reset());\r\n  }\r\n}\r\n","import { CommonModule } from '@angular/common';\r\nimport { NgModule } from '@angular/core';\r\nimport { MentionDirective } from './mention.directive';\r\nimport { MentionListComponent } from './mention-list.component';\r\n\r\n@NgModule({\r\n  declarations: [\r\n    MentionDirective,\r\n    MentionListComponent\r\n  ],\r\n  imports: [\r\n    CommonModule\r\n  ],\r\n  exports: [\r\n    MentionDirective\r\n  ],\r\n  entryComponents: [\r\n    MentionListComponent\r\n  ]\r\n})\r\nexport class MentionModule { }\r\n"]}